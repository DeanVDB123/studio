
'use server';

import { generateBiographyDraft, type GenerateBiographyDraftInput } from '@/ai/flows/generate-biography-draft';
import { organizeUserContent, type OrganizeUserContentInput } from '@/ai/flows/organize-user-content';
import type { MemorialData, OrganizedContent } from '@/lib/types';
import { createMemorial as dbCreateMemorial, saveMemorial as dbSaveMemorial } from '@/lib/data';
import { revalidatePath } from 'next/cache';
import { v4 as uuidv4 } from 'uuid'; // Import for fallback ID generation if needed

export async function handleGenerateBiography(input: GenerateBiographyDraftInput): Promise<string> {
  try {
    const result = await generateBiographyDraft(input);
    return result.biographyDraft;
  } catch (error) {
    console.error('Error generating biography draft:', error);
    throw new Error('Failed to generate biography. Please try again.');
  }
}

export async function handleOrganizeContent(input: OrganizeUserContentInput): Promise<OrganizedContent> {
  try {
    const result = await organizeUserContent(input);
    return result.organizedContent;
  } catch (error) {
    console.error('Error organizing content:', error);
    throw new Error('Failed to organize content. Please try again.');
  }
}

export async function saveMemorialAction(
  userId: string,
  memorialData: MemorialData,
  isUpdate: boolean // Explicit flag to determine operation type
): Promise<MemorialData> {
  if (!userId) {
    console.error('[Action] User ID is missing in saveMemorialAction.');
    throw new Error("User ID is required to save a memorial.");
  }
  try {
    let savedMemorial: MemorialData;
    // Ensure the authenticated userId is stamped on the data being saved
    const dataToSave: MemorialData = { ...memorialData, userId };

    if (isUpdate) {
      if (!dataToSave.id) {
        // This should ideally not happen if isUpdate is true, as ID should come from the existing memorial
        console.error('[Action] Attempting to UPDATE, but memorialData.id is missing. This indicates a flow error.');
        throw new Error('Cannot update memorial without a valid Memorial ID.');
      }
      console.log(`[Action] Attempting to UPDATE memorial. ID: ${dataToSave.id}, User: ${userId}`);
      savedMemorial = await dbSaveMemorial(dataToSave.id, userId, dataToSave);
    } else { // This is a CREATE operation
      // The form should have already generated an ID for new memorials and put it in memorialData.id
      if (!dataToSave.id) {
          console.warn('[Action] Attempting to CREATE, but memorialData.id was not pre-generated by the form. Generating one in action as fallback.');
          dataToSave.id = uuidv4(); // Fallback, though form should ensure this
      }
      console.log(`[Action] Attempting to CREATE new memorial. ID: ${dataToSave.id}, User: ${userId}`);
      savedMemorial = await dbCreateMemorial(userId, dataToSave);
    }

    revalidatePath('/admin');
    if (savedMemorial.id) {
       revalidatePath(`/admin/edit/${savedMemorial.id}`);
       revalidatePath(`/memorial/${savedMemorial.id}`);
    }
    console.log(`[Action] Memorial ${isUpdate ? 'updated' : 'created'} successfully: ${savedMemorial.id}`);
    return savedMemorial;
  } catch (error: any) {
    const errorMessage = error.message || `Failed to ${isUpdate ? 'update' : 'create'} memorial data. Please try again.`;
    console.error(`[Action] Error in saveMemorialAction (isUpdate: ${isUpdate}, memorialId: ${memorialData.id}):`, error);
    // It's generally better to throw a new error with a potentially more specific message
    // or to ensure the original error is an instance of Error.
    throw new Error(errorMessage);
  }
}
